// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"products/graph/model"
	"sync"
	"time"
)

// __resolveReference is the resolver for the __resolveReference field.
func (r *Resolver) __resolveReference(ctx context.Context, obj interface{}) (interface{}, error) {
	// Extrair o ID da referência
	var id string
	switch v := obj.(type) {
	case map[string]interface{}:
		if idVal, ok := v["id"]; ok {
			if idStr, ok := idVal.(string); ok {
				id = idStr
			}
		}
	case *model.Product:
		id = v.ID
	}

	if id == "" {
		return nil, nil
	}

	// Buscar o produto pelo ID
	for _, product := range products {
		if product.ID == id {
			return product, nil
		}
	}

	return nil, nil
}

// Products is the resolver for the products field.
func (r *Resolver) Products(ctx context.Context) ([]*model.Product, error) {
	return products, nil
}

// Product is the resolver for the product field.
func (r *Resolver) Product(ctx context.Context, id string) (*model.Product, error) {
	for _, product := range products {
		if product.ID == id {
			return product, nil
		}
	}
	return nil, nil
}

// ProductsByIds is the resolver for the productsByIds field.
func (r *Resolver) ProductsByIds(ctx context.Context, ids []string) ([]*model.Product, error) {
	// Configurar contexto com timeout
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Criar canal para resultados e erros
	resultChan := make(chan *model.Product, len(ids))
	errorChan := make(chan error, len(ids))

	// WaitGroup para aguardar todas as goroutines
	var wg sync.WaitGroup

	// Função para buscar um produto individual
	fetchProduct := func(productID string) {
		defer wg.Done()

		// Simular latência de rede/database
		select {
		case <-time.After(100 * time.Millisecond):
			// Simular latência variável
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		}

		// Verificar se o contexto foi cancelado
		select {
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		default:
		}

		// Buscar produto
		for _, product := range products {
			if product.ID == productID {
				resultChan <- product
				return
			}
		}

		// Produto não encontrado
		errorChan <- nil
	}

	// Iniciar goroutines para cada ID
	for _, id := range ids {
		wg.Add(1)
		go fetchProduct(id)
	}

	// Goroutine para aguardar conclusão e fechar canais
	go func() {
		wg.Wait()
		close(resultChan)
		close(errorChan)
	}()

	// Coletar resultados
	var results []*model.Product
	var errors []error

	// Coletar produtos encontrados
	for product := range resultChan {
		if product != nil {
			results = append(results, product)
		}
	}

	// Verificar erros
	for err := range errorChan {
		if err != nil {
			errors = append(errors, err)
		}
	}

	// Se houve erros de contexto, retornar o primeiro
	if len(errors) > 0 {
		return results, errors[0]
	}

	return results, nil
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *Resolver) ProductsByCategory(ctx context.Context, category string) ([]*model.Product, error) {
	var results []*model.Product

	for _, product := range products {
		if product.Category == category {
			results = append(results, product)
		}
	}

	return results, nil
}

// ProductsWithSemaphore is the resolver for the productsWithSemaphore field.
func (r *Resolver) ProductsWithSemaphore(ctx context.Context, ids []string) ([]*model.Product, error) {
	// Configurar contexto com timeout
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Criar canal para resultados e erros
	resultChan := make(chan *model.Product, len(ids))
	errorChan := make(chan error, len(ids))

	// WaitGroup para aguardar todas as goroutines
	var wg sync.WaitGroup

	// Função para buscar um produto individual com semáforo
	fetchProductWithSemaphore := func(productID string) {
		defer wg.Done()

		// Adquirir permissão do semáforo
		if err := r.semaphore.Acquire(ctx); err != nil {
			errorChan <- err
			return
		}
		defer r.semaphore.Release()

		// Simular latência de rede/database (mais longa para demonstrar backpressure)
		select {
		case <-time.After(200 * time.Millisecond):
			// Simular latência variável
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		}

		// Verificar se o contexto foi cancelado
		select {
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		default:
		}

		// Buscar produto
		for _, product := range products {
			if product.ID == productID {
				resultChan <- product
				return
			}
		}

		// Produto não encontrado
		errorChan <- nil
	}

	// Iniciar goroutines para cada ID
	for _, id := range ids {
		wg.Add(1)
		go fetchProductWithSemaphore(id)
	}

	// Goroutine para aguardar conclusão e fechar canais
	go func() {
		wg.Wait()
		close(resultChan)
		close(errorChan)
	}()

	// Coletar resultados
	var results []*model.Product
	var errors []error

	// Coletar produtos encontrados
	for product := range resultChan {
		if product != nil {
			results = append(results, product)
		}
	}

	// Verificar erros
	for err := range errorChan {
		if err != nil {
			errors = append(errors, err)
		}
	}

	// Se houve erros de contexto, retornar o primeiro
	if len(errors) > 0 {
		return results, errors[0]
	}

	return results, nil
}

// SemaphoreStats is the resolver for the semaphoreStats field.
func (r *Resolver) SemaphoreStats(ctx context.Context) (*model.SemaphoreStats, error) {
	stats := r.semaphore.Stats()

	return &model.SemaphoreStats{
		Max:       stats["max"],
		Current:   stats["current"],
		Available: stats["available"],
		Usage:     stats["usage"],
	}, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
