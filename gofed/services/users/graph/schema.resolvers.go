// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"sync"
	"time"
	"users/graph/model"
)

// __resolveReference is the resolver for the __resolveReference field.
func (r *Resolver) __resolveReference(ctx context.Context, obj interface{}) (interface{}, error) {
	// Extrair o ID da referência
	var id string
	switch v := obj.(type) {
	case map[string]interface{}:
		if idVal, ok := v["id"]; ok {
			if idStr, ok := idVal.(string); ok {
				id = idStr
			}
		}
	case *model.User:
		id = v.ID
	}

	if id == "" {
		return nil, nil
	}

	// Buscar o usuário pelo ID
	for _, user := range users {
		if user.ID == id {
			return user, nil
		}
	}

	return nil, nil
}

// Users is the resolver for the users field.
func (r *Resolver) Users(ctx context.Context) ([]*model.User, error) {
	return users, nil
}

// User is the resolver for the user field.
func (r *Resolver) User(ctx context.Context, id string) (*model.User, error) {
	for _, user := range users {
		if user.ID == id {
			return user, nil
		}
	}
	return nil, nil
}

// UsersByIds is the resolver for the usersByIds field.
func (r *Resolver) UsersByIds(ctx context.Context, ids []string) ([]*model.User, error) {
	// Configurar contexto com timeout
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Criar canal para resultados e erros
	resultChan := make(chan *model.User, len(ids))
	errorChan := make(chan error, len(ids))

	// WaitGroup para aguardar todas as goroutines
	var wg sync.WaitGroup

	// Função para buscar um usuário individual
	fetchUser := func(userID string) {
		defer wg.Done()

		// Simular latência de rede/database
		select {
		case <-time.After(100 * time.Millisecond):
			// Simular latência variável
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		}

		// Verificar se o contexto foi cancelado
		select {
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		default:
		}

		// Buscar usuário
		for _, user := range users {
			if user.ID == userID {
				resultChan <- user
				return
			}
		}

		// Usuário não encontrado
		errorChan <- nil
	}

	// Iniciar goroutines para cada ID
	for _, id := range ids {
		wg.Add(1)
		go fetchUser(id)
	}

	// Goroutine para aguardar conclusão e fechar canais
	go func() {
		wg.Wait()
		close(resultChan)
		close(errorChan)
	}()

	// Coletar resultados
	var results []*model.User
	var errors []error

	// Coletar usuários encontrados
	for user := range resultChan {
		if user != nil {
			results = append(results, user)
		}
	}

	// Verificar erros
	for err := range errorChan {
		if err != nil {
			errors = append(errors, err)
		}
	}

	// Se houve erros de contexto, retornar o primeiro
	if len(errors) > 0 {
		return results, errors[0]
	}

	return results, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
