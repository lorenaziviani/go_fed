package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"users/graph/model"
)

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// UsersByIds is the resolver for the usersByIds field.
func (r *queryResolver) UsersByIds(ctx context.Context, ids []string) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: UsersByIds - usersByIds"))
}

// UsersFromCache is the resolver for the usersFromCache field.
func (r *queryResolver) UsersFromCache(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: UsersFromCache - usersFromCache"))
}

// UserFromCache is the resolver for the userFromCache field.
func (r *queryResolver) UserFromCache(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UserFromCache - userFromCache"))
}

// CacheStats is the resolver for the cacheStats field.
func (r *queryResolver) CacheStats(ctx context.Context) (*model.CacheStats, error) {
	panic(fmt.Errorf("not implemented: CacheStats - cacheStats"))
}

// SimulateRaceCondition is the resolver for the simulateRaceCondition field.
func (r *queryResolver) SimulateRaceCondition(ctx context.Context) (*model.RaceConditionResult, error) {
	panic(fmt.Errorf("not implemented: SimulateRaceCondition - simulateRaceCondition"))
}

// SimulateSafeAccess is the resolver for the simulateSafeAccess field.
func (r *queryResolver) SimulateSafeAccess(ctx context.Context) (*model.SafeAccessResult, error) {
	panic(fmt.Errorf("not implemented: SimulateSafeAccess - simulateSafeAccess"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *Resolver) __resolveReference(ctx context.Context, obj interface{}) (interface{}, error) {
	// Extrair o ID da referência
	var id string
	switch v := obj.(type) {
	case map[string]interface{}:
		if idVal, ok := v["id"]; ok {
			if idStr, ok := idVal.(string); ok {
				id = idStr
			}
		}
	case *model.User:
		id = v.ID
	}

	if id == "" {
		return nil, nil
	}

	// Buscar o usuário pelo ID
	for _, user := range users {
		if user.ID == id {
			return user, nil
		}
	}

	return nil, nil
}
func (r *Resolver) Users(ctx context.Context) ([]*model.User, error) {
	return users, nil
}
func (r *Resolver) User(ctx context.Context, id string) (*model.User, error) {
	for _, user := range users {
		if user.ID == id {
			return user, nil
		}
	}
	return nil, nil
}
func (r *Resolver) UsersByIds(ctx context.Context, ids []string) ([]*model.User, error) {
	// Configurar contexto com timeout
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Criar canal para resultados e erros
	resultChan := make(chan *model.User, len(ids))
	errorChan := make(chan error, len(ids))

	// WaitGroup para aguardar todas as goroutines
	var wg sync.WaitGroup

	// Função para buscar um usuário individual
	fetchUser := func(userID string) {
		defer wg.Done()

		// Simular latência de rede/database
		select {
		case <-time.After(100 * time.Millisecond):
			// Simular latência variável
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		}

		// Verificar se o contexto foi cancelado
		select {
		case <-ctx.Done():
			errorChan <- ctx.Err()
			return
		default:
		}

		// Buscar usuário
		for _, user := range users {
			if user.ID == userID {
				resultChan <- user
				return
			}
		}

		// Usuário não encontrado
		errorChan <- nil
	}

	// Iniciar goroutines para cada ID
	for _, id := range ids {
		wg.Add(1)
		go fetchUser(id)
	}

	// Goroutine para aguardar conclusão e fechar canais
	go func() {
		wg.Wait()
		close(resultChan)
		close(errorChan)
	}()

	// Coletar resultados
	var results []*model.User
	var errors []error

	// Coletar usuários encontrados
	for user := range resultChan {
		if user != nil {
			results = append(results, user)
		}
	}

	// Verificar erros
	for err := range errorChan {
		if err != nil {
			errors = append(errors, err)
		}
	}

	// Se houve erros de contexto, retornar o primeiro
	if len(errors) > 0 {
		return results, errors[0]
	}

	return results, nil
}
func (r *Resolver) UsersFromCache(ctx context.Context) ([]*model.User, error) {
	// Buscar usuários do cache (thread-safe)
	cachedUsers := r.cache.GetUsersSafe()

	// Se cache vazio, popular com dados mock
	if len(cachedUsers) == 0 {
		for _, user := range users {
			r.cache.SetUserSafe(user)
		}
		cachedUsers = r.cache.GetUsersSafe()
	}

	return cachedUsers, nil
}
func (r *Resolver) UserFromCache(ctx context.Context, id string) (*model.User, error) {
	// Buscar usuário do cache (thread-safe)
	if user, exists := r.cache.GetUserSafe(id); exists {
		return user, nil
	}

	// Se não encontrado no cache, buscar nos dados mock
	for _, user := range users {
		if user.ID == id {
			// Adicionar ao cache
			r.cache.SetUserSafe(user)
			return user, nil
		}
	}

	return nil, nil
}
func (r *Resolver) CacheStats(ctx context.Context) (*model.CacheStats, error) {
	stats := r.cache.Stats()

	return &model.CacheStats{
		Size:    stats["size"].(int),
		MaxSize: stats["max_size"].(int),
		Ttl:     stats["ttl"].(string),
	}, nil
}
func (r *Resolver) SimulateRaceCondition(ctx context.Context) (*model.RaceConditionResult, error) {
	start := time.Now()

	// Simular race condition (PODE CAUSAR PANIC!)
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("Race condition detected: %v\n", r)
		}
	}()

	r.cache.SimulateRaceCondition()

	duration := time.Since(start)

	return &model.RaceConditionResult{
		Success:  true,
		Message:  "Race condition simulation completed (may have caused issues)",
		Duration: duration.String(),
	}, nil
}
func (r *Resolver) SimulateSafeAccess(ctx context.Context) (*model.SafeAccessResult, error) {
	start := time.Now()

	// Simular acesso seguro (thread-safe)
	r.cache.SimulateSafeAccess()

	duration := time.Since(start)

	return &model.SafeAccessResult{
		Success:  true,
		Message:  "Safe access simulation completed successfully",
		Duration: duration.String(),
	}, nil
}
*/
